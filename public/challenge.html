<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>é—¯å…³æ¨¡å¼ - å•è¯å™©æ¢¦</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 min-h-screen flex items-center justify-center">
  <div class="w-full max-w-lg bg-white rounded shadow p-6">
    <h1 class="text-2xl font-bold mb-4 text-center">5000 å•è¯é—¯å…³ï¼ˆæ¯å…³ 100 é¢˜ï¼‰</h1>

    <div class="flex gap-2 mb-3">
      <select id="mode" class="flex-1 border px-2 py-1 rounded">
        <option value="en-zh">è‹± â†’ ä¸­</option>
        <option value="zh-en">ä¸­ â†’ è‹±</option>
        <option value="random">éšæœº</option>
      </select>

      <select id="selectLevel" class="w-40 border px-2 py-1 rounded"></select>

      <button id="btnStart" class="bg-blue-600 text-white px-3 rounded">å¼€å§‹</button>
    </div>

    <div id="meta" class="text-sm text-gray-500 mb-3">è¯·é€‰æ‹©å…³å¡å¹¶ç‚¹å‡»å¼€å§‹ï¼ˆæ”¯æŒä»é”™é¢˜åº“ä¼ å‚ç»ƒä¹ ï¼‰</div>

    <div id="questionArea" class="mb-3">
      <div id="question" class="text-xl font-semibold mb-2">è¯·ç‚¹å‡»å¼€å§‹</div>
      <input id="answer" class="w-full border px-3 py-2 rounded" placeholder="åœ¨æ­¤è¾“å…¥ç­”æ¡ˆ" autocomplete="off" />
    </div>

    <button id="btnSubmit" class="w-full bg-green-500 text-white py-2 rounded mb-2">æäº¤ç­”æ¡ˆ</button>
    <div id="feedback" class="mb-2 min-h-[28px]"></div>

    <div class="flex gap-2">
      <button id="btnNext" class="flex-1 bg-gray-200 py-2 rounded">è·³è¿‡ / ä¸‹ä¸€é¢˜</button>
      <a href="index.html" class="flex-1 text-center bg-gray-300 py-2 rounded">è¿”å›é¦–é¡µ</a>
    </div>
  </div>

<script>
  // ---------- è¾…åŠ©å‡½æ•° ----------
  function isChinese(text){ return /[\u4e00-\u9fff]/.test(text); }
  function normalizeEn(s){ return (s||'').replace(/[^a-z0-9]/gi,'').toLowerCase(); }
  function normalizeZh(s){ return (s||'').replace(/\s+/g,'').trim(); }

  function commonCharRatio(a,b){
    if(!a||!b) return 0;
    let common = 0;
    for(const ch of a){
      if(b.includes(ch)) common++;
    }
    return common / Math.max(b.length,1);
  }

  // æ¨¡ç³ŠåŒ¹é…ï¼šåŒºåˆ†ä¸­/è‹±
  function fuzzyMatch(user, expected){
    if(!user || !expected) return false;
    if (isChinese(expected)){
      const a = normalizeZh(user);
      const b = normalizeZh(expected);
      if(!a || !b) return false;
      if (b.includes(a) || a.includes(b)) return true;
      return commonCharRatio(a,b) >= 0.6;
    } else {
      const a = normalizeEn(user);
      const b = normalizeEn(expected);
      if(!a || !b) return false;
      if (a === b) return true;
      if (b.includes(a) || a.includes(b)) return true;
      return commonCharRatio(a,b) >= 0.6;
    }
  }

  // ä¿å­˜é”™é¢˜ï¼Œå­˜å¯¹è±¡ { en, zh, when }
  function saveWrongItem(item){
    try{
      const key = 'wrongs';
      const arr = JSON.parse(localStorage.getItem(key) || '[]');
      // é¿å…é‡å¤ï¼šä»¥ en + zh ä½œä¸ºå”¯ä¸€åˆ¤å®šï¼ˆè‹¥ç¼º zh åˆ™ç”¨ enï¼‰
      const exists = arr.some(x => x.en === item.en && x.zh === item.zh);
      if(!exists){
        arr.push({ ...item, when: Date.now() });
        localStorage.setItem(key, JSON.stringify(arr));
      }
    }catch(e){
      console.error('ä¿å­˜é”™é¢˜å¤±è´¥', e);
    }
  }

  // ---------- DOM & çŠ¶æ€ ----------
  const modeEl = document.getElementById('mode');
  const selectLevelEl = document.getElementById('selectLevel');
  const btnStart = document.getElementById('btnStart');
  const questionEl = document.getElementById('question');
  const answerEl = document.getElementById('answer');
  const feedbackEl = document.getElementById('feedback');
  const btnSubmit = document.getElementById('btnSubmit');
  const btnNext = document.getElementById('btnNext');
  const metaEl = document.getElementById('meta');

  let wordsByLevel = {};
  let currentLevel = 1;
  let currentList = [];
  let currentIndex = 0;
  let currentMode = 'en-zh';

  // å½“å‰é¢˜ç›®çŠ¶æ€
  let currentEnWord = '';     // è‹±æ–‡åŸè¯ï¼ˆwords.json çš„å€¼ï¼‰
  let currentPrompt = '';     // æ˜¾ç¤ºç»™ç”¨æˆ·çš„æç¤ºï¼ˆå¯èƒ½æ˜¯è‹±æ–‡æˆ–ä¸­æ–‡ï¼‰
  let expectedAnswer = '';    // æˆ‘ä»¬ç”¨æ¥åˆ¤åˆ†çš„æ ‡å‡†ç­”æ¡ˆï¼ˆä¸­æ–‡æˆ–è‹±æ–‡ï¼‰
  let fetching = false;

  // ---------- åŠ è½½è¯åº“ & æ”¯æ’‘å‡½æ•° ----------
  async function loadWordsJson(){
    try {
      const r = await fetch('words.json');
      wordsByLevel = await r.json();
      // å¡«å……å…³å¡é€‰æ‹©
      const keys = Object.keys(wordsByLevel).sort((a,b)=>{
        const na = Number(a.replace('level',''));
        const nb = Number(b.replace('level',''));
        return na - nb;
      });
      selectLevelEl.innerHTML = keys.map(k => {
        const n = k.replace('level','');
        return `<option value="${n}">ç¬¬ ${n} å…³</option>`;
      }).join('');
      // å¦‚æœæœ‰ practice å‚æ•°ï¼ˆä»é”™é¢˜åº“è·³è½¬ï¼‰ï¼Œå¤„ç†
      const params = new URLSearchParams(window.location.search);
      const practice = params.get('practice');
      if(practice){
        // æŠŠå•è¯æ”¾åˆ° currentList å•é¢˜ç»ƒä¹ 
        currentList = [practice];
        currentLevel = 0; // æ ‡è¯†ä¸ºç»ƒä¹ å•è¯ï¼Œä¸ç®—å…³å¡
        questionEl.textContent = 'ç»ƒä¹ æŒ‡å®šå•è¯ï¼ˆæ¥è‡ªé”™é¢˜åº“ï¼‰';
        // ç›´æ¥å¼€å§‹å‡†å¤‡é¢˜ç›®
        currentMode = 'en-zh';
        await prepareQuestion();
      }
    } catch(err){
      console.error('è½½å…¥è¯åº“å¤±è´¥', err);
      questionEl.textContent = 'è½½å…¥è¯åº“å¤±è´¥ï¼Œè¯·æ£€æŸ¥ public/words.json';
    }
  }

  function setLevel(n){
    currentLevel = Number(n);
    currentList = wordsByLevel['level' + currentLevel] || [];
    currentIndex = 0;
  }

  // ---------- è¯·æ±‚ç¿»è¯‘å¹¶å‡†å¤‡é¢˜ç›® ----------
  async function prepareQuestion(){
    if(fetching) return;
    feedbackEl.textContent = '';
    // å¦‚æœ currentList æœªè®¾ç½®ï¼ˆæœªé€‰æ‹©å…³å¡ï¼‰ï¼Œä» selectLevel åˆå§‹åŒ–
    if(!currentList || currentList.length === 0){
      setLevel(selectLevelEl.value || 1);
    }
    if(currentIndex >= currentList.length){
      // æœ¬å…³å®Œæˆ
      const nextKey = 'level' + (currentLevel + 1);
      if(wordsByLevel[nextKey]){
        alert(`ç¬¬ ${currentLevel} å…³å®Œæˆï¼è¿›å…¥ç¬¬ ${currentLevel+1} å…³`);
        setLevel(currentLevel + 1);
      } else {
        questionEl.textContent = 'ğŸ‰ å·²å®Œæˆæ‰€æœ‰å…³å¡ï¼ˆæˆ–æ— ä¸‹ä¸€å…³ï¼‰';
        answerEl.style.display = 'none';
        return;
      }
    }

    const enWord = currentList[currentIndex];
    currentEnWord = enWord;
    // è®¡ç®—å½“å‰å®é™…æ¨¡å¼ï¼ˆè‹¥ä¸º randomï¼Œåˆ™éšæœºé€‰ä¸€ä¸ªæ–¹å‘ï¼‰
    let mode = currentMode;
    if(mode === 'random') mode = Math.random() < 0.5 ? 'en-zh' : 'zh-en';

    // è¯·æ±‚åç«¯è·å¾—å¿…è¦çš„ç¿»è¯‘ç»“æœï¼ˆå¦‚æœç½‘ç»œæˆ– API å‡ºé—®é¢˜ä¼šæç¤ºï¼‰
    try {
      fetching = true;
      btnSubmit.disabled = true;
      btnNext.disabled = true;
      metaEl.textContent = `åŠ è½½é¢˜ç›®ï¼šç¬¬ ${currentLevel>0?currentLevel:'?'} å…³ ç¬¬ ${currentIndex+1} é¢˜ï¼ˆæ–¹å‘ï¼š${mode}ï¼‰`;

      if(mode === 'en-zh'){
        // prompt: è‹±æ–‡ï¼› expectedAnswer: ä¸­æ–‡ï¼ˆç”±åç«¯è·å–ï¼‰
        currentPrompt = enWord;
        // è°ƒç”¨åç«¯ï¼šè½¬æ¢ en->zh
        const res = await fetch(`/api/baiduTranslate?word=${encodeURIComponent(enWord)}`);
        const data = await res.json();
        if(data && data.trans_result && data.trans_result[0] && data.trans_result[0].dst){
          expectedAnswer = data.trans_result[0].dst;
        } else {
          expectedAnswer = '';
          console.warn('ç¿»è¯‘æœªè¿”å›ä¸­æ–‡', data);
        }
        questionEl.textContent = `ç¬¬ ${currentLevel} å…³ ç¬¬ ${currentIndex+1} é¢˜ï¼šè‹± â†’ ä¸­  è¯·ç¿»è¯‘ï¼š ${currentPrompt}`;
      } else {
        // zh-en: we need chinese prompt (from enWord's translation), expectedAnswer = enWord
        const res = await fetch(`/api/baiduTranslate?word=${encodeURIComponent(enWord)}`);
        const data = await res.json();
        const zh = (data && data.trans_result && data.trans_result[0]) ? data.trans_result[0].dst : '';
        currentPrompt = zh || enWord; // è‹¥ç¿»è¯‘å¤±è´¥åˆ™å›é€€æ˜¾ç¤ºè‹±æ–‡ï¼ˆå¹¶å‘ŠçŸ¥ï¼‰
        expectedAnswer = enWord;
        questionEl.textContent = `ç¬¬ ${currentLevel} å…³ ç¬¬ ${currentIndex+1} é¢˜ï¼šä¸­ â†’ è‹±  è¯·ç¿»è¯‘ï¼š ${currentPrompt}`;
      }
    } catch(err){
      console.error('prepareQuestion error', err);
      questionEl.textContent = 'åŠ è½½é¢˜ç›®å¤±è´¥ï¼šè¯·æ£€æŸ¥ /api/baiduTranslate æ˜¯å¦å¯ç”¨';
      expectedAnswer = '';
    } finally {
      fetching = false;
      btnSubmit.disabled = false;
      btnNext.disabled = false;
      answerEl.value = '';
      feedbackEl.textContent = '';
    }
  }

  // ---------- æäº¤åˆ¤åˆ† ----------
  btnSubmit.addEventListener('click', ()=>{
    if(fetching) { feedbackEl.textContent = 'æ­£åœ¨åŠ è½½é¢˜ç›®ï¼Œè¯·ç¨å€™...'; return; }
    const user = answerEl.value.trim();
    if(!user){ feedbackEl.textContent = 'è¯·è¾“å…¥ç­”æ¡ˆåå†æäº¤'; return; }

    // åˆ¤æ–­å½“å‰å®é™…æ¨¡å¼ï¼ˆè‹¥éšæœºåˆ™æŒ‰ä¸Šæ¬¡ prepareQuestion ç¡®å®šï¼‰
    let mode = currentMode;
    if(mode === 'random'){
      // decide by seeing question text: if question contains "è‹± â†’ ä¸­" then mode=en-zh else zh-en
      mode = questionEl.textContent.includes('è‹± â†’ ä¸­') ? 'en-zh' : 'zh-en';
    }

    const ok = fuzzyMatch(user, expectedAnswer);
    if(ok){
      feedbackEl.innerHTML = '<span class="text-green-600">âœ… ç­”å¯¹</span>';
    } else {
      feedbackEl.innerHTML = `<span class="text-red-600">âŒ é”™è¯¯ï¼Œæ ‡å‡†ç­”æ¡ˆï¼š${expectedAnswer || '(æœªè·å–)'}</span>`;
      // ä¿å­˜é”™é¢˜ï¼šè®°å½• en + zh
      if(mode === 'en-zh'){
        // expectedAnswer æ˜¯ä¸­æ–‡ï¼ˆå¯èƒ½ä¸ºç©ºï¼‰ï¼Œ currentEnWord æ˜¯è‹±æ–‡
        saveWrongItem({ en: currentEnWord, zh: expectedAnswer || '' });
      } else {
        // zh-enï¼š expectedAnswer æ˜¯è‹±æ–‡åŸè¯ï¼Œ currentPrompt ä¸ºä¸­æ–‡æç¤ºï¼ˆæˆ–è‹±æ–‡å›é€€ï¼‰
        saveWrongItem({ en: expectedAnswer || currentEnWord, zh: currentPrompt || '' });
      }
    }

    // ä¸‹ä¸€é¢˜
    currentIndex++;
    setTimeout(()=> {
      prepareQuestion();
    }, 900);
  });

  // è·³è¿‡/ä¸‹ä¸€é¢˜
  btnNext.addEventListener('click', ()=>{
    if(fetching) return;
    currentIndex++;
    prepareQuestion();
  });

  // å¼€å§‹æŒ‰é’®ï¼šåŠ è½½ levelï¼Œå¹¶ prepare first question
  btnStart.addEventListener('click', async ()=>{
    currentMode = modeEl.value;
    const lvl = Number(selectLevelEl.value || 1);
    setLevel(lvl);
    await prepareQuestion();
  });

  // ---------- é¡µé¢åŠ è½½ ----------
  (async function init(){
    await loadWordsJson();

    // æ”¯æŒ url å‚æ•° practice=xxxï¼ˆæ¥è‡ªé”™é¢˜åº“ï¼‰
    const params = new URLSearchParams(window.location.search);
    const practice = params.get('practice');
    if(practice){
      // practice å·²åœ¨ loadWordsJson ä¸­å¤„ç†ï¼Œè‹¥ words.json æœªåŠ è½½å®Œä¼šåœ¨ loadWordsJson åè°ƒç”¨ prepareQuestion
      // è¿™é‡Œç¡®ä¿åˆ‡æ¢ mode ä¸º en-zhï¼ˆç»ƒä¹ é”™é¢˜æ—¶ä¼˜å…ˆè‹±â†’ä¸­ï¼‰
      modeEl.value = 'en-zh';
      currentMode = 'en-zh';
    } else {
      // è‹¥é practiceï¼Œåˆ™é»˜è®¤é€‰æ‹©ç¬¬1å…³
      selectLevelEl.value = selectLevelEl.value || '1';
      setLevel(Number(selectLevelEl.value || 1));
    }
  })();
</script>
</body>
</html>
